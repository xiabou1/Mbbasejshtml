<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Mandelbulb REAL Avanzado con Luces y Estereoscópico Mejorado</title>
  <style>
    body {
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      border: 1px solid #555;
      margin: 1rem;
      background: black;
    }
    .controls {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.5rem 1rem;
      background: #333;
      padding: 1rem;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
    }
    .controls label {
      text-align: right;
    }
    .controls input, .controls select, .controls button {
      width: 200px;
    }
    #progressContainer {
      width: 600px;
      height: 20px;
      background-color: #555;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 1rem;
    }
    #progressBar {
      height: 100%;
      width: 0%;
      background-color: #4CAF50;
      text-align: center;
      line-height: 20px;
      color: white;
      transition: width 0.1s ease-out;
    }
  </style>
</head>
<body>
  <h1>Mandelbulb REAL con Múltiples Luces y Estereoscopía Mejorada</h1>
  <canvas id="canvas" width="600" height="600"></canvas>

  <div class="controls">
    <label>Distancia de Cámara (Zoom Inicial):</label>
    <input type="range" id="cameraDistance" min="0" max="12" step="0.1" value="0">

    <label>Zoom del Fractal (potencia 1.5):</label>
    <input type="range" id="fractalZoom" min="0" max="20" step="0.1" value="0">

    <label>Rotación Polar:</label>
    <input type="range" id="polar" min="0" max="360" step="1" value="150">

    <label>Rotación Azimutal:</label>
    <input type="range" id="azimuthal" min="0" max="360" step="1" value="140">

    <label>Pan X:</label>
    <input type="range" id="panX" min="-2" max="2" step="0.01" value="0">

    <label>Pan Y:</label>
    <input type="range" id="panY" min="-2" max="2" step="0.01" value="0">

    <label>Detalle (potencia negativa 1.5):</label>
    <input type="range" id="minDist" min="0" max="21" step="0.1" value="2">

    <label>Tamaño de Píxel:</label>
    <select id="pixelSize">
      <option value="1">1x1</option>
      <option value="2">2x2</option>
      <option value="4">4x4</option>
    </select>

    <label>Modo de Renderizado:</label>
    <select id="renderMode">
      <option value="normal">Normal</option>
      <option value="stereoscopic">Estereoscópico</option>
    </select>

    <label>Separación de Cámara (Estéreo):</label>
    <input type="range" id="eyeSeparation" min="-4" max="4" step="0.001" value="0.08">

    <label>Factor de Convergencia (Estéreo):</label>
    <input type="range" id="convergenceFactor" min="-4" max="4" step="0.01" value="1.0">
    
    <label>Precisión de Ajuste (Estéreo):</label>
    <input type="range" id="stereoStepPrecision" min="1" max="100" step="1" value="10">

    <label>Iteraciones Mandelbulb (Max):</label>
    <input type="range" id="maxMandelbulbIterations" min="5" max="50" step="1" value="20">

    <label>Pasos Raymarching (Max):</label>
    <input type="range" id="maxRaymarchingSteps" min="50" max="400" step="10" value="100">

    <label>Balance de Iluminación (Pasos vs. Phong):</label>
    <input type="range" id="lightingBalance" min="1" max="9" step="1" value="5">

    <label>Brillo:</label>
    <input type="range" id="brightness" min="0" max="200" step="1" value="100">

    <div></div>
    <button id="autoAdjustEyes">Ajustar Ojos (Target Fijo)</button>
    <button id="autoAdjustTarget">Ajustar Target (Ojos Fijos)</button>
    <button id="exportImage">Exportar Imagen</button>
  </div>

  <div id="progressContainer">
    <div id="progressBar">0%</div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const progressBar = document.getElementById("progressBar");
    const exportImageButton = document.getElementById("exportImage");
    const brightnessSlider = document.getElementById("brightness");

    // Parámetros
    let cameraDistanceExp = 0;
    let fractalZoomExp = 0;
    let polar = 150;
    let azimuthal = 140;
    let panX = 0;
    let panY = 0;
    let minDistExp = 2;
    let pixelSize = 1;
    let renderMode = "normal";

    let eyeSeparation = 0.08;
    let convergenceFactor = 1.0;
    let stereoStepPrecision = 10;

    let maxMandelbulbIterations = 20;
    let maxRaymarchingSteps = 100;
    let lightingBalance = 5;
    let brightnessFactor = 1.0; // Nuevo parámetro para el brillo


    let cancelRender = false;

    const vec3 = () => [0,0,0];
    const eyeBase = vec3();
    const centerBase = [0,0,0];

    let lastCentralHitPoint = null;

    // --- Web Worker setup ---
    const NUM_WORKERS = navigator.hardwareConcurrency || 4;
    const workers = [];
    let activeWorkers = 0;
    let renderedPixels = 0;
    let totalPixels = 0;
    const currentImageData = ctx.createImageData(width, height);

    for (let i = 0; i < NUM_WORKERS; i++) {
        const worker = new Worker('mandelbulbWorker.js');
        workers.push(worker);

        worker.onmessage = function(e) {
            if (e.data.command === 'chunkRendered') {
                const { imageData: chunkImageData, yStart, yEnd, renderedPixelsInChunk } = e.data;
                
                const chunkHeight = yEnd - yStart;
                for (let y = 0; y < chunkHeight; y++) {
                    for (let x = 0; x < width; x++) {
                        const idxMain = 4 * ((yStart + y) * width + x);
                        const idxChunk = 4 * (y * width + x);
                        
                        currentImageData.data[idxMain + 0] = chunkImageData.data[idxChunk + 0];
                        currentImageData.data[idxMain + 1] = chunkImageData.data[idxChunk + 1];
                        currentImageData.data[idxMain + 2] = chunkImageData.data[idxChunk + 2];
                        currentImageData.data[idxMain + 3] = chunkImageData.data[idxChunk + 3];
                    }
                }

                renderedPixels += renderedPixelsInChunk;
                activeWorkers--;
                updateProgressBar();

                // Aplicar brillo al ImageData principal antes de dibujar
                // NOTA: applyBrightness ahora opera directamente sobre currentImageData.data
                // y no es necesario re-aplicarlo en el render final si ya se hizo progresivamente.
                // Sin embargo, para asegurar consistencia, se aplica cada vez que un chunk llega.
                // Si el brillo se quiere aplicar SOLO al final, esta línea debería ir al final del if (activeWorkers === 0)
                // y quitarse de aquí. Para feedback visual, se mantiene aquí.
                
                // ctx.putImageData(currentImageData, 0, 0); // Esto se hace al final del chunk

                if (activeWorkers === 0) {
                    // Solo aplicar brillo una vez al final, si se desea.
                    // Si se aplica arriba, esta línea no es estrictamente necesaria aquí.
                    applyBrightness(currentImageData.data, brightnessFactor); // Asegura que el brillo final se aplica
                    ctx.putImageData(currentImageData, 0, 0);
                    progressBar.style.width = '100%';
                    progressBar.textContent = '100% - Completo';
                    console.log("Renderizado completo con workers.");
                } else {
                    // Si no es el último chunk, aplicar brillo y dibujar progresivamente.
                    // Clonar para aplicar brillo sin modificar los datos que otros workers podrían estar usando
                    // (aunque en este setup, cada worker tiene su propio chunkImageData, y currentImageData es el destino final)
                    const tempImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), width, height);
                    applyBrightness(tempImageData.data, brightnessFactor);
                    ctx.putImageData(tempImageData, 0, 0);
                }
            }
        };

        worker.onerror = function(error) {
            console.error("Worker error:", error);
        };
    }

    // Función para aplicar el brillo directamente a los datos de píxeles
    function applyBrightness(data, factor) {
        for (let i = 0; i < data.length; i += 4) {
            data[i + 0] = Math.min(255, Math.max(0, Math.floor(data[i + 0] * factor)));   // R
            data[i + 1] = Math.min(255, Math.max(0, Math.floor(data[i + 1] * factor)));   // G
            data[i + 2] = Math.min(255, Math.max(0, Math.floor(data[i + 2] * factor)));   // B
            // El alpha (data[i + 3]) se mantiene igual
        }
    }

    function updateProgressBar() {
        const progress = Math.floor((renderedPixels / totalPixels) * 100);
        progressBar.style.width = progress + '%';
        progressBar.textContent = progress + '%';
    }
    // --- Fin Web Worker setup ---

    // Elementos del DOM para los sliders
    const cameraDistanceSlider = document.getElementById("cameraDistance");
    const eyeSeparationSlider = document.getElementById("eyeSeparation");
    const convergenceFactorSlider = document.getElementById("convergenceFactor");
    const stereoStepPrecisionSlider = document.getElementById("stereoStepPrecision");
    const autoAdjustEyesButton = document.getElementById("autoAdjustEyes");
    const autoAdjustTargetButton = document.getElementById("autoAdjustTarget");
    const maxMandelbulbIterationsInput = document.getElementById("maxMandelbulbIterations");
    const maxRaymarchingStepsInput = document.getElementById("maxRaymarchingSteps");
    const lightingBalanceSlider = document.getElementById("lightingBalance");
    const minDistSlider = document.getElementById("minDist"); // Slider de detalle
    const brightnessInput = document.getElementById("brightness"); // Nuevo input para brillo


    // Ajustar el valor máximo del slider de detalle
    const originalMaxMinDist = parseFloat(minDistSlider.max);
    minDistSlider.max = originalMaxMinDist * 3;
    // Actualizar el valor si el valor actual era el máximo original
    if (parseFloat(minDistSlider.value) === originalMaxMinDist) {
        minDistSlider.value = minDistSlider.max;
        minDistExp = parseFloat(minDistSlider.value);
    }


    // Controles
    cameraDistanceSlider.oninput = e => { cameraDistanceExp = parseFloat(e.target.value); restart(); };
    document.getElementById("fractalZoom").oninput = e => { fractalZoomExp = parseFloat(e.target.value); restart(); };
    document.getElementById("polar").oninput = e => { polar = parseFloat(e.target.value); restart(); };
    document.getElementById("azimuthal").oninput = e => { azimuthal = parseFloat(e.target.value); restart(); };
    document.getElementById("panX").oninput = e => { panX = parseFloat(e.target.value); restart(); };
    document.getElementById("panY").oninput = e => { panY = parseFloat(e.target.value); restart(); };
    minDistSlider.oninput = e => { minDistExp = parseFloat(e.target.value); restart(); };
    document.getElementById("pixelSize").onchange = e => { pixelSize = parseInt(e.target.value); restart(); };
    document.getElementById("renderMode").onchange = e => { renderMode = e.target.value; restart(); };

    eyeSeparationSlider.oninput = e => { eyeSeparation = parseFloat(e.target.value); restart(); };
    convergenceFactorSlider.oninput = e => { convergenceFactor = parseFloat(e.target.value); restart(); };
    
    stereoStepPrecisionSlider.oninput = e => {
      stereoStepPrecision = parseInt(e.target.value);
      const stepValue = 1 / stereoStepPrecision;
      eyeSeparationSlider.step = stepValue;
      convergenceFactorSlider.step = stepValue;
    };

    maxMandelbulbIterationsInput.oninput = e => { maxMandelbulbIterations = parseInt(e.target.value); restart(); };
    maxRaymarchingStepsInput.oninput = e => { maxRaymarchingSteps = parseInt(e.target.value); restart(); };
    lightingBalanceSlider.oninput = e => { lightingBalance = parseInt(e.target.value); restart(); };
    brightnessInput.oninput = e => { brightnessFactor = parseFloat(e.target.value) / 100; restart(); }; // Factor de 0 a 2


    // --- Funciones matemáticas duplicadas en el hilo principal para findBestStereoMatch ---
    function normalize_main(v) {
        let l = Math.hypot(v[0], v[1], v[2]);
        if (l === 0) return [0,0,0];
        return [v[0]/l, v[1]/l, v[2]/l];
    }
    function dot_main(a, b) {
        return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
    }
    function cross_main(a,b) {
        return [
            a[1]*b[2] - a[2]*b[1],
            a[2]*b[0] - a[0]*b[2],
            a[0]*b[1] - a[1]*b[0]
        ];
    }
    function add_main(a,b) {
        return [a[0]+b[0], a[1]+b[1], a[2]+b[2]];
    }
    function sub_main(a,b) {
        return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
    }
    function mul_main(v, s) {
        return [v[0]*s, v[1]*s, v[2]*s];
    }

    function mandelbulb_main_thread(p) {
        let z = [...p];
        let dr = 1.0;
        let r = 0.0;
        const Power = 8;
        for (let i = 0; i < maxMandelbulbIterations; i++) {
            r = Math.hypot(z[0], z[1], z[2]);
            if (r > 2.0) break;

            let theta = Math.acos(z[2]/r);
            let phi = Math.atan2(z[1], z[0]);

            dr = Math.pow(r, Power - 1.0) * Power * dr + 1.0;

            let zr = Math.pow(r, Power);
            theta *= Power;
            phi *= Power;

            z[0] = zr * Math.sin(theta) * Math.cos(phi) + p[0];
            z[1] = zr * Math.sin(theta) * Math.sin(phi) + p[1];
            z[2] = zr * Math.cos(theta) + p[2];
        }
        return 0.5 * Math.log(r) * r / dr;
    }

    function traceRay_main_thread(startPos, direction, maxSteps, minDistThreshold, fractalScale) {
        let p = [...startPos];
        let hit = false;
        let distance = 0;

        for (let i = 0; i < maxSteps; i++) {
            let d = mandelbulb_main_thread(p);

            d *= fractalScale;

            if (d < minDistThreshold) {
                hit = true;
                break;
            }
            if (d > 4.0 * fractalScale) break;
            p = add_main(p, mul_main(direction, d));
            distance += d;
        }
        return { hit: hit, point: p, distance: distance };
    }
    // --- Fin Funciones para ajuste automático ---

    async function findBestStereoMatch(adjustEyeSeparation, fixedValue) {
        cancelRender = true;
        await new Promise(resolve => {
            if (activeWorkers === 0) resolve();
            else {
                const checkInterval = setInterval(() => {
                    if (activeWorkers === 0) {
                        clearInterval(checkInterval);
                        resolve();
                    }
                }, 50);
            }
        });

        progressBar.style.width = '100%';
        progressBar.textContent = 'Ajustando...';

        const currentCameraDistance = 4.0 * Math.pow(10, -cameraDistanceExp);
        const currentFractalScale = Math.pow(1.5, -fractalZoomExp);
        const currentMinDist = Math.pow(1.5, -minDistExp);

        let bestValue = adjustEyeSeparation ? eyeSeparation : convergenceFactor;
        let minDifference = Infinity;

        let minSearch = adjustEyeSeparation ? parseFloat(eyeSeparationSlider.min) : parseFloat(convergenceFactorSlider.min);
        let maxSearch = adjustEyeSeparation ? parseFloat(eyeSeparationSlider.max) : parseFloat(convergenceFactorSlider.max);

        const iterations = 20;
        const raysPerAttempt = 30;

        for (let iter = 0; iter < iterations; iter++) {
            let testValue = minSearch + (maxSearch - minSearch) * (iter / (iterations - 1));
            if (iterations === 1) testValue = minSearch;

            let totalDifference = 0;
            let validHits = 0;

            const initialUp = [0, 1, 0];

            const eyeBaseInitial = vec3();
            eyeBaseInitial[0] = currentCameraDistance * Math.sin(polar * Math.PI/180) * Math.cos(azimuthal * Math.PI/180);
            eyeBaseInitial[1] = currentCameraDistance * Math.cos(polar * Math.PI/180);
            eyeBaseInitial[2] = currentCameraDistance * Math.sin(polar * Math.PI/180) * Math.sin(azimuthal * Math.PI/180);

            const cameraLookAtCenter = [panX, panY, 0];

            const forwardBaseInitial = normalize_main(sub_main(cameraLookAtCenter, eyeBaseInitial));
            const rightBaseInitial = normalize_main(cross_main(forwardBaseInitial, initialUp));
            const trueUpBaseInitial = cross_main(rightBaseInitial, forwardBaseInitial);

            for (let i = 0; i < raysPerAttempt; i++) {
                const uOffset = (Math.random() - 0.5) * 0.5;
                const vOffset = (Math.random() - 0.5) * 0.5;

                const xCentral = width / 2 + uOffset * height;
                const yCentral = height / 2 + vOffset * height;

                // --- Calculate ray for LEFT eye ---
                let currentEyeL;
                let currentCenterL;

                let eyeSeparationL = adjustEyeSeparation ? testValue : fixedValue;
                let convergenceFactorL = adjustEyeSeparation ? fixedValue : testValue;

                let offsetDirectionL = -1;
                let eyeOffsetL = mul_main(rightBaseInitial, offsetDirectionL * eyeSeparationL);
                currentEyeL = add_main(eyeBaseInitial, eyeOffsetL);

                let targetPointL = lastCentralHitPoint || cameraLookAtCenter;
                let centerOffsetL = mul_main(rightBaseInitial, offsetDirectionL * eyeSeparationL * convergenceFactorL);
                currentCenterL = add_main(targetPointL, centerOffsetL);

                let forwardL = normalize_main(sub_main(currentCenterL, currentEyeL));
                let rightL = normalize_main(cross_main(forwardL, trueUpBaseInitial));
                let trueUpL = cross_main(rightL, forwardL);

                let uL = (xCentral - width/2) / height * 1.0;
                let vL = (yCentral - height/2) / height * 1.0;
                let dirL = normalize_main(add_main(add_main(forwardL, mul_main(rightL, uL * currentFractalScale)), mul_main(trueUpL, vL * currentFractalScale)));

                const hitResultL = traceRay_main_thread(currentEyeL, dirL, maxRaymarchingSteps, currentMinDist, currentFractalScale);

                // --- Calculate ray for RIGHT eye ---
                let currentEyeR;
                let currentCenterR;

                let eyeSeparationR = adjustEyeSeparation ? testValue : fixedValue;
                let convergenceFactorR = adjustEyeSeparation ? fixedValue : testValue;

                let offsetDirectionR = 1;
                let eyeOffsetR = mul_main(rightBaseInitial, offsetDirectionR * eyeSeparationR);
                currentEyeR = add_main(eyeBaseInitial, eyeOffsetR);

                let targetPointR = lastCentralHitPoint || cameraLookAtCenter;
                let centerOffsetR = mul_main(rightBaseInitial, offsetDirectionR * eyeSeparationR * convergenceFactorR);
                currentCenterR = add_main(targetPointR, centerOffsetR);

                let forwardR = normalize_main(sub_main(currentCenterR, currentEyeR));
                let rightR = normalize_main(cross_main(forwardR, trueUpBaseInitial));
                let trueUpR = cross_main(rightR, forwardR);

                let uR = (xCentral - width/2) / height * 1.0;
                let vR = (yCentral - height/2) / height * 1.0;
                let dirR = normalize_main(add_main(add_main(forwardR, mul_main(rightR, uR * currentFractalScale)), mul_main(trueUpR, vR * currentFractalScale)));

                const hitResultR = traceRay_main_thread(currentEyeR, dirR, maxRaymarchingSteps, currentMinDist, currentFractalScale);

                if (hitResultL.hit && hitResultR.hit) {
                    const diff = sub_main(hitResultL.point, hitResultR.point);
                    totalDifference += dot_main(diff, diff);
                    validHits++;
                } else if (!hitResultL.hit && !hitResultR.hit) {
                    totalDifference += 10;
                    validHits++;
                } else {
                    totalDifference += 100000;
                    validHits++;
                }
            }

            if (validHits > 0) {
                const averageDifference = totalDifference / validHits;
                if (averageDifference < minDifference) {
                    minDifference = averageDifference;
                    bestValue = testValue;
                }
            }

            if (iter < iterations - 1) {
                const mid = (minSearch + maxSearch) / 2;
                if (bestValue < mid) {
                    maxSearch = mid;
                } else {
                    minSearch = mid;
                }
            }

            await new Promise(resolve => setTimeout(resolve, 10));
            const progress = Math.floor((iter / iterations) * 100);
            progressBar.textContent = `Ajustando... ${progress}%`;
        }

        if (adjustEyeSeparation) {
            eyeSeparation = bestValue;
            eyeSeparationSlider.value = eyeSeparation;
            console.log("Auto-ajuste de eyeSeparation:", eyeSeparation);
        } else {
            convergenceFactor = bestValue;
            convergenceFactorSlider.value = convergenceFactor;
            console.log("Auto-ajuste de convergenceFactor:", convergenceFactor);
        }

        progressBar.textContent = '100% - Ajuste Completo';
        cancelRender = false;
        render();
    }


    autoAdjustEyesButton.onclick = async () => {
        await findBestStereoMatch(true, convergenceFactor);
    };

    autoAdjustTargetButton.onclick = async () => {
        await findBestStereoMatch(false, eyeSeparation);
    };

    function restart() {
      cancelRender = true;
      activeWorkers = 0;
      renderedPixels = 0;
      progressBar.style.width = '0%';
      progressBar.textContent = '0%';
      ctx.clearRect(0,0,width,height);
      setTimeout(() => {
        cancelRender = false;
        render();
      }, 100);
    }


    async function render() {
        if (cancelRender) return;

        const currentCameraDistance = 4.0 * Math.pow(10, -cameraDistanceExp);
        const currentFractalScale = Math.pow(1.5, -fractalZoomExp);
        const currentMinDist = Math.pow(1.5, -minDistExp);

        eyeBase[0] = currentCameraDistance * Math.sin(polar * Math.PI/180) * Math.cos(azimuthal * Math.PI/180);
        eyeBase[1] = currentCameraDistance * Math.cos(polar * Math.PI/180);
        eyeBase[2] = currentCameraDistance * Math.sin(polar * Math.PI/180) * Math.sin(azimuthal * Math.PI/180);
        
        let cameraPosition = add_main(eyeBase, [panX, panY, 0]);

        let cameraLookAtTarget = [0,0,0];

        let initialUp = [0, 1, 0];

        let forwardBase = normalize_main(sub_main(cameraLookAtTarget, cameraPosition));
        let rightBase = normalize_main(cross_main(forwardBase, initialUp));
        let trueUpBase = cross_main(rightBase, forwardBase);

        let centralRayDir = normalize_main(add_main(add_main(forwardBase, mul_main(rightBase, 0 * currentFractalScale)), mul_main(trueUpBase, 0 * currentFractalScale)));
        const centralHitResult = traceRay_main_thread(cameraPosition, centralRayDir, maxRaymarchingSteps, currentMinDist, currentFractalScale);
        lastCentralHitPoint = centralHitResult.hit ? centralHitResult.point : null;


        renderedPixels = 0;
        totalPixels = (width * height) / (pixelSize * pixelSize);
        updateProgressBar();
        ctx.clearRect(0,0,width,height);

        activeWorkers = NUM_WORKERS;
        const chunkHeightPx = Math.ceil(height / NUM_WORKERS);

        for (let i = 0; i < NUM_WORKERS; i++) {
            const yStart = i * chunkHeightPx;
            const yEnd = Math.min(yStart + chunkHeightPx, height);
            
            workers[i].postMessage({
                command: 'renderChunk',
                params: {
                    cameraDistanceExp,
                    fractalZoomExp,
                    polar,
                    azimuthal,
                    panX,
                    panY,
                    minDistExp,
                    pixelSize,
                    renderMode,
                    eyeSeparation,
                    convergenceFactor,
                    maxMandelbulbIterations,
                    maxRaymarchingSteps,
                    lastCentralHitPoint,
                    lightingBalance
                },
                width: width,
                height: height,
                yStart: yStart,
                yEnd: yEnd,
            });
        }
    }

    exportImageButton.onclick = function() {
        // Asegurarse de que el brillo final se aplique al ImageData antes de exportar
        // Si el brillo se aplica progresivamente, currentImageData ya debería estar correcto.
        // Si no, se podría llamar applyBrightness(currentImageData.data, brightnessFactor); aquí.
        // Para mayor seguridad, se puede forzar un re-render final si no está completo.
        if (activeWorkers > 0) {
            console.warn("Renderizado en progreso. Espere a que termine para una exportación precisa.");
            // Opcional: deshabilitar el botón hasta que activeWorkers === 0
            // o forzar un render final síncrono (no recomendado para fractales complejos).
        }
        
        const dataURL = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = 'mandelbulb.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    };

    document.addEventListener('DOMContentLoaded', (event) => {
      const initialStep = 1 / parseInt(stereoStepPrecisionSlider.value);
      eyeSeparationSlider.step = initialStep;
      convergenceFactorSlider.step = initialStep;
      brightnessInput.value = brightnessFactor * 100; // Inicializar el valor del slider de brillo
      render();
    });

  </script>
</body>
</html>

